import matplotlib.pyplot as plt
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import csv
import pandas as pd
from collections import Counter
import time


# File containing data sample, generated by NumberGenerator
data_file = ''

# Reads a csv and returns a 2D list containing data
def read_csv(file_handle):
    data = []
    with open(file_handle) as csvfile:
        spamreader = csv.reader(csvfile, delimiter=',', quotechar="'")
        for row in spamreader:
            data.append(row)
        return data

# Plots data from main as a scatter plot of x vs y
def plot_data(x, y, xlabel, ylabel):
    for iter in range(len(x)):
        print(x[iter], y[iter])
        plt.scatter(x[iter], y[iter], color='b', s=0.2)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.show()
    plt.close()


# Takes two lists, uses 80% of the sample to create the weights for the algorithm, and then shows head and tail of algorithm vs confirmed values
def predict_number(game, answer):
    # Reshape X to 2D numpy matrix for algorithm
    game_reshape = np.array(game).reshape(-1, 1)

    # Split data 80 20 for test and train
    game_train, game_test, answer_train, answer_test = train_test_split(game_reshape, answer, test_size=0.2, random_state=0)

    # Create the linear regression model and send it training data
    linear_method = LinearRegression()
    linear_method.fit(game_train, answer_train)

    # Now put model to the test
    answer_pred = linear_method.predict(game_test)

    # And demonstrate the accuracy
    diff = pd.DataFrame({'Actual': answer_test, 'Predicted': answer_pred.flatten()})
    print(diff)

    #Return our newly trained model
    return linear_method


def get_best_move(regression_model, sample_size, games):
    #Create a list of new games
    new_games = []
    new_game = sample_size + 1
    #Create a list to hold new predictions
    predictions = []

    for values in range(games):
        #Create new games from our sample data that trained model
        new_games.append(values + sample_size)

    # Reshape new games to fit algorithm
    new_games_reshaped = np.array(new_games).reshape(-1, 1)

    # Get new predictions for our data
    answer_pred = regression_model.predict(new_games_reshaped)

    # Find most common prediction, and return it
    #best_move = most_frequent(answer_pred)

    # Remove decimal nonsense from answer
    return int(answer_pred)


def most_frequent(List):

    # Keep track of all element occurences, and return the most common one
    occurence_count = Counter(List)
    return occurence_count.most_common(1)[0][0]


def main():

    # Time our AI for time taken to train and predict
    t = time.perf_counter()

    #Grab our sample
    data = read_csv(data_file)


    x = []
    y = []

    # Build list of y data, in this case, number between 1 and 10
    for each in data:
        y.append(int(each[1]))

    # Build list of x data, in this case, games
    for rows in range(len(data)):
        x.append(rows + 1)


    # Create our model, and find the best move using said model
    model = predict_number(x, y)
    best_move = get_best_move(model, len(y), 1)

    # End timer now that program has ended
    t = time.perf_counter() - t

    print(f'\nThe winning move is playing {best_move}, and was theorized in {round((t / 60), 3)} minutes and {round(t % 60, 4)} seconds')


if __name__ == '__main__':
    main()